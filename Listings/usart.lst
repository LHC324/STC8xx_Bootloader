C51 COMPILER V9.60.0.0   USART                                                             01/14/2023 22:17:10 PAGE 1   


C51 COMPILER V9.60.0.0, COMPILATION OF MODULE USART
OBJECT MODULE PLACED IN .\Objects\usart.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE Src\usart.c LARGE OPTIMIZE(9,SPEED) BROWSE FLOATFUZZY(4) INCDIR(.\Inc) D
                    -EBUG OBJECTEXTEND PRINT(.\Listings\usart.lst) OBJECT(.\Objects\usart.obj)

line level    source

   1          #include "usart.h"
   2          #include "GPIO.h"
   3          #if (DWIN_USING_RB)
              #include "utils_ringbuffer.h"
              #endif
   6          /*********************************************************
   7          * å‡½æ•°åï¼š
   8          * åŠŸèƒ½ï¼š
   9          * å‚æ•°ï¼š
  10          * ä½œè€…ï¼š
  11          * noteï¼š
  12                  åŒæ—¶ä½¿ç”¨å¤šä¸ªä¸²å£çš„æ—¶å€™ä¼šå‡ºç°æ•°æ®ä¼ è¾“é”™è¯¯çš„æƒ…å†µ å»ºè®®åœ¨ä½¿ç”¨è¯¥æ¿å­ä¸å
             -…¶ä»–
  13                  é€šè®¯æ¨¡å—å»ºç«‹é€šè®¯çš„æ—¶å€™ä½¿ç”¨1å¯¹1çš„å»ºç«‹è¿æ¥çš„æ¨¡å¼
  14          
  15                  è§£å†³äº†å¤šä¸²å£åŒæ—¶æ•°æ®ä¼ è¾“é”™è¯¯é—®é¢˜ //2021/5/31
  16          
  17                  åœ¨åˆ‡æ¢ä¸²å£çš„å¼•è„šè¾“å…¥æ—¶ï¼Œå»ºè®®å°†RXç«¯åˆå§‹åŒ–çš„æ—¶å€™ç»™ä¸ª0å€¼ TXå¼•è„šæ‰‹åŠ¨ç»™ä¸
             -ª1å€¼
  18                  ï¼ˆåŸºäºSTCå•ç‰‡æœºçš„ç‰¹æ€§ï¼‰
  19          
  20          **********************************************************/
  21          
  22          #if (OTA_UART != 5U)
              void (*IspProgram)(void) = ISP_PROGRAM_ADDR;
              char cnt7f = 0;
              #else
  26          // Uartx_HandleTypeDef Boot_Rx = {0};
  27          // uint8_t uart2_buf[1024];
  28          #if (DWIN_USING_RB)
              struct ringbuffer rm_rb = {
                  Boot_Rx.Rx_buffer,
                  sizeof(Boot_Rx.Rx_buffer) - 1U,
                  0,
                  0,
              };
              #endif
  36          #endif
  37          
  38          Uart_HandleTypeDef Uart1; // ä¸²å£1å¥æŸ„
  39          Uart_HandleTypeDef Uart2; // ä¸²å£2å¥æŸ„
  40          // Uart_HandleTypeDef Uart3; // ä¸²å£3å¥æŸ„
  41          // Uart_HandleTypeDef Uart4; // ä¸²å£4å¥æŸ„
  42          
  43          #if !defined USING_SIMULATE
              /*********************************************************
               * å‡½æ•°åï¼švoid Uart_1Init(void)
               * åŠŸèƒ½ï¼š  ä¸²å£1çš„åˆå§‹åŒ–
               * å‚æ•°ï¼š
               * ä½œè€…ï¼š  LHC
               * noteï¼š
               *              ä½¿ç”¨çš„æ˜¯å®šæ—¶å™¨1ä½œä¸ºæ³¢ç‰¹ç‡å‘ç”Ÿå™¨,LANå£ç”¨
               **********************************************************/
              void Uart1_Init(void) // ä¸²å£1é€‰æ‹©å®šæ—¶å™¨1ä½œä¸ºæ³¢ç‰¹ç‡å‘ç”Ÿå™¨
C51 COMPILER V9.60.0.0   USART                                                             01/14/2023 22:17:10 PAGE 2   

              {
                  Uart1.Instance = UART1;
                  Uart1.Register_SCON = 0x50; // æ¨¡å¼1ï¼Œ8ä½æ•°æ®ï¼Œå¯å˜æ³¢ç‰¹ç‡
                  Uart1.Uart_Mode = 0x00;     // å®šæ—¶å™¨æ¨¡å¼0ï¼Œ16bitè‡ªåŠ¨é‡è½½
                  Uart1.Uart_Count = BRT_1T(BAUD_115200);
                  Uart1.RunUart_Enable = true;
                  Uart1.Interrupt_Enable = true;
                  Uart1.Register_AUXR = 0x40;  // å®šæ—¶å™¨1ï¼Œ1Tæ¨¡å¼
                  Uart1.Register_AUXR &= 0xFE; // æ³¢ç‰¹ç‡å‘ç”Ÿå™¨é€‰ç”¨å®šæ—¶å™¨1ï¼Œæœ€å¥½æŒ‰ç…§è¦æ±‚æ¥
              
                  Uart1.Uart_NVIC.Register_IP = 0xEF; // PS=0,PSH=0,ä¸²å£1ä¸­æ–­ä¼˜å…ˆçº§ä¸ºç¬¬0çº§ï¼Œæœ€ä½çº§
                  Uart1.Uart_NVIC.Register_IPH = 0xEF;
              
                  Uart_Base_MspInit(&Uart1);
              }
              
              #if (UAING_AUTO_DOWNLOAD)
              /**
               * @brief    è½¯ä»¶å¤ä½è‡ªåŠ¨ä¸‹è½½åŠŸèƒ½ï¼Œéœ€è¦åœ¨ä¸²å£ä¸­æ–­é‡Œè°ƒç”¨ï¼Œ
               *           éœ€è¦åœ¨STC-ISPåŠ©æ‰‹é‡Œè®¾ç½®ä¸‹è½½å£ä»¤ï¼š10ä¸ª0x7Fã€‚
               * @details  Software reset automatic download function,
               *                       need to be called in serial interrupt,
               *                       The download password needs to be
               *                       set in the STC-ISP assistant: 10 0x7F.
               * @param    None.
               * @return   None.
               **/
              void Auto_RST_download(void)
              {
                  static uint8_t semCont = 0;
                  if (SBUF == 0x7F || SBUF == 0x80)
                  {
                      if (++semCont >= 10)
                      {
                          semCont = 0;
                          IAP_CONTR = 0x60;
                      }
                  }
                  else
                  {
                      semCont = 0;
                  }
              }
              #endif
              
              // #if (OTA_UART != 5U)
              /*********************************************************
               * å‡½æ•°åï¼švoid Uart1_ISR() interrupt 4 using 2
               * åŠŸèƒ½ï¼š  ä¸²å£1çš„å®šæ—¶ä¸­æ–­æœåŠ¡å‡½æ•°
               * å‚æ•°ï¼š
               * ä½œè€…ï¼š  LHC
               * noteï¼š
               *              ä½¿ç”¨çš„æ˜¯å®šæ—¶å™¨2ä½œä¸ºæ³¢ç‰¹ç‡å‘ç”Ÿå™¨,485å£ç”¨
               **********************************************************/
              void Uart1_ISR() interrupt 4 using 2 // ä¸²å£1çš„å®šæ—¶ä¸­æ–­æœåŠ¡å‡½æ•°
              {
                  if (TI) // å‘é€ä¸­æ–­æ ‡å¿—
                  {
                      TI = 0;
                      Uart1.Uartx_busy = false; // å‘é€å®Œæˆï¼Œæ¸…é™¤å ç”¨
                  }
              
C51 COMPILER V9.60.0.0   USART                                                             01/14/2023 22:17:10 PAGE 3   

                  if (RI) // æ¥æ”¶ä¸­æ–­æ ‡å¿—
                  {
              #if (OTA_UART == 1)
                      if (SBUF == 0x7F)
                      {
                          cnt7f++;
                          if (cnt7f >= 16)
                          {
                              IspProgram();
                          }
                      }
                      else
                      {
                          cnt7f = 0;
                      }
              #endif
              
                      RI = 0;
              #if (UAING_AUTO_DOWNLOAD)
                      Auto_RST_download();
              #endif
                  }
              }
              #endif
 139          
 140          /*********************************************************
 141           * å‡½æ•°åï¼švoid Uart_2Init(void)
 142           * åŠŸèƒ½ï¼š  ä¸²å£2çš„åˆå§‹åŒ–
 143           * å‚æ•°ï¼š
 144           * ä½œè€…ï¼š  LHC
 145           * noteï¼š
 146           *              ä½¿ç”¨çš„æ˜¯å®šæ—¶å™¨2ä½œä¸ºæ³¢ç‰¹ç‡å‘ç”Ÿå™¨,485å£ç”¨
 147           **********************************************************/
 148          void Uart2_Init(void) // ä¸²å£2é€‰æ‹©å®šæ—¶å™¨2ä½œä¸ºæ³¢ç‰¹ç‡å‘ç”Ÿå™¨
 149          {
 150   1          Uart2.Instance = UART2;
 151   1          Uart2.Register_SCON = 0x10; // æ¨¡å¼1ï¼Œ8ä½æ•°æ®ï¼Œå¯å˜æ³¢ç‰¹ç‡ï¼Œå¼€å¯ä¸²å£2æ¥æ”¶
 152   1          Uart2.Uart_Mode = 0x00;     // å®šæ—¶å™¨æ¨¡å¼0ï¼Œ16bitè‡ªåŠ¨é‡è½½
 153   1          Uart2.Uart_Count = BRT_1T(BAUD_115200);
 154   1          Uart2.RunUart_Enable = true;
 155   1          Uart2.Interrupt_Enable = 0x01;
 156   1          Uart2.Register_AUXR = 0x14;         // å¼€å¯å®šæ—¶å™¨2ï¼Œ1Tæ¨¡å¼
 157   1          Uart2.Uart_NVIC.Register_IP = 0x01; // PS2=1,PS2H=0,ä¸²å£2ä¸­æ–­ä¼˜å…ˆçº§ä¸ºç¬¬1çº§
 158   1          Uart2.Uart_NVIC.Register_IPH = 0xFE;
 159   1      
 160   1          Uart_Base_MspInit(&Uart2);
 161   1      }
 162          
 163          // #if (OTA_UART != 5U)
 164          /*********************************************************
 165           * å‡½æ•°åï¼švoid Uart2_ISR() interrupt 8 using 2
 166           * åŠŸèƒ½ï¼š  ä¸²å£2ä¸­æ–­å‡½æ•°
 167           * å‚æ•°ï¼š
 168           * ä½œè€…ï¼š  LHC
 169           * noteï¼š
 170           *              ä½¿ç”¨çš„æ˜¯å®šæ—¶å™¨2ä½œä¸ºæ³¢ç‰¹ç‡å‘ç”Ÿå™¨,4Gå£ç”¨
 171           **********************************************************/
 172          // void Uart2_ISR() interrupt 8 using 2
 173          // {
 174          //     // static uint16_t i = 0;
 175          //     // static uint16_t site = 0;
 176          // #if (DWIN_USING_RB)
C51 COMPILER V9.60.0.0   USART                                                             01/14/2023 22:17:10 PAGE 4   

 177          //     struct ringbuffer *const rb = &rm_rb;
 178          // #endif
 179          //     if (S2CON & S2TI) // å‘é€ä¸­æ–­
 180          //     {
 181          //         S2CON &= ~S2TI;
 182          //         Uart2.Uartx_busy = false; // å‘é€å®Œæˆï¼Œæ¸…é™¤å ç”¨
 183          //     }
 184          
 185          //     if (S2CON & S2RI) // æ¥æ”¶ä¸­æ–­
 186          //     {
 187          //         S2CON &= ~S2RI;
 188          // #if (DWIN_USING_RB)
 189          //         // if (Uart4.pbuf && Uart4.rx_count < rx_size)
 190          //         //     Uart4.pbuf[Uart4.rx_count++] = S4BUF;
 191          //         if (NULL == rb->buf)
 192          //             return;
 193          
 194          //         // rb->buf[rb->write_index & rb->size] = S2BUF;
 195          //         // site = rb->write_index % rb->size;
 196          //         // uart2_buf[site] = S2BUF;
 197          //         // if (fingbuffer_get_num(rb) > 128)
 198          //         //     while (1)
 199          //         //         ;
 200          
 201          //         rb->buf[rb->write_index & rb->size] = S2BUF;
 202          //         /*
 203          //          * buffer full strategy: new data will overwrite the oldest data in
 204          //          * the buffer
 205          //          */
 206          //         if ((rb->write_index - rb->read_index) > rb->size)
 207          //         {
 208          //             rb->read_index = rb->write_index - rb->size;
 209          //         }
 210          
 211          //         rb->write_index++;
 212          
 213          //         // if (fingbuffer_get_num(rb) > 128)
 214          //         //     while (1)
 215          //         //         ;
 216          // #endif
 217          
 218          // #if (OTA_UART == 2)
 219          //         if (S2BUF == 0x7F)
 220          //         {
 221          //             cnt7f++;
 222          //             if (cnt7f >= 16)
 223          //             {
 224          //                 IspProgram();
 225          //             }
 226          //         }
 227          //         else
 228          //         {
 229          //             cnt7f = 0;
 230          //         }
 231          // #endif
 232          //     }
 233          // }
 234          // #endif
 235          
 236          /**********************************å…¬ç”¨å‡½æ•°************************/
 237          
 238          /*********************************************************
C51 COMPILER V9.60.0.0   USART                                                             01/14/2023 22:17:10 PAGE 5   

 239           * å‡½æ•°åï¼šUart_Base_MspInit(Uart_HandleTypeDef *uart_baseHandle)
 240           * åŠŸèƒ½ï¼š  æ‰€æœ‰ä¸²å£åº•å±‚åˆå§‹åŒ–å‡½æ•°
 241           * å‚æ•°ï¼š  Uart_HandleTypeDef *uart_baseHandleä¸²å£å¥æŸ„
 242           * ä½œè€…ï¼š  LHC
 243           * noteï¼š
 244           *              æ³¨æ„æ­£ç¡®ç»™å‡ºä¸²å£å¥æŸ„
 245           **********************************************************/
 246          void Uart_Base_MspInit(Uart_HandleTypeDef *const uart_baseHandle)
 247          {
 248   1          GPIO_InitTypeDef GPIO_InitStruct = {0};
 249   1          switch (uart_baseHandle->Instance)
 250   1          {
 251   2          case UART1:
 252   2          {
 253   3              SCON = uart_baseHandle->Register_SCON;
 254   3              TMOD |= uart_baseHandle->Uart_Mode;
 255   3              TL1 = uart_baseHandle->Uart_Count;
 256   3              TH1 = uart_baseHandle->Uart_Count >> 8;
 257   3              TR1 = uart_baseHandle->RunUart_Enable;
 258   3              AUXR |= uart_baseHandle->Register_AUXR;
 259   3              IP &= uart_baseHandle->Uart_NVIC.Register_IP;
 260   3              IPH &= uart_baseHandle->Uart_NVIC.Register_IPH;
 261   3      #if USEING_PRINTF // å¦‚æœä½¿ç”¨printf
                      TI = 1;   // æ”¾åˆ°printfé‡å®šå‘
              #else
 264   3              ES = uart_baseHandle->Interrupt_Enable; // ä¸²å£1ä¸­æ–­å…è®¸ä½
 265   3      #endif
 266   3              /*è®¾ç½®P3.0ä¸ºå‡†åŒå‘å£*/
 267   3              GPIO_InitStruct.Mode = GPIO_PullUp;
 268   3              GPIO_InitStruct.Pin = GPIO_Pin_0;
 269   3              GPIO_Inilize(GPIO_P3, &GPIO_InitStruct);
 270   3      
 271   3              /*è®¾ç½®P3.1ä¸ºæ¨æŒ½è¾“å‡º*/
 272   3              GPIO_InitStruct.Mode = GPIO_OUT_PP;
 273   3              GPIO_InitStruct.Pin = GPIO_Pin_1;
 274   3              GPIO_Inilize(GPIO_P3, &GPIO_InitStruct);
 275   3          }
 276   2          break;
 277   2          case UART2:
 278   2          {
 279   3              S2CON = uart_baseHandle->Register_SCON;
 280   3              TL2 = uart_baseHandle->Uart_Count;
 281   3              TH2 = uart_baseHandle->Uart_Count >> 8;
 282   3              AUXR |= uart_baseHandle->Register_AUXR;
 283   3              IE2 = (uart_baseHandle->Interrupt_Enable & 0x01); // ä¸²å£2ä¸­æ–­å…è®¸ä½
 284   3              IP2 &= uart_baseHandle->Uart_NVIC.Register_IP;
 285   3              IP2H &= uart_baseHandle->Uart_NVIC.Register_IPH;
 286   3              /*è®¾ç½®P1.0ä¸ºå‡†åŒå‘å£*/
 287   3              GPIO_InitStruct.Mode = GPIO_PullUp;
 288   3              GPIO_InitStruct.Pin = GPIO_Pin_0;
 289   3              GPIO_Inilize(GPIO_P1, &GPIO_InitStruct);
 290   3      
 291   3              /*è®¾ç½®P1.1ä¸ºæ¨æŒ½è¾“å‡º*/
 292   3              GPIO_InitStruct.Mode = GPIO_OUT_PP;
 293   3              GPIO_InitStruct.Pin = GPIO_Pin_1;
 294   3              GPIO_Inilize(GPIO_P1, &GPIO_InitStruct);
 295   3          }
 296   2          break;
 297   2          // case UART3:
 298   2          // {
 299   2          //     S3CON = uart_baseHandle->Register_SCON;
 300   2          //     T4T3M = uart_baseHandle->Uart_Mode;
C51 COMPILER V9.60.0.0   USART                                                             01/14/2023 22:17:10 PAGE 6   

 301   2          //     T3L = uart_baseHandle->Uart_Count;
 302   2          //     T3H = uart_baseHandle->Uart_Count >> 8;
 303   2          //     IE2 |= (uart_baseHandle->Interrupt_Enable & 0x08); // ä¸²å£3ä¸­æ–­å…è®¸ä½
 304   2      
 305   2          //     /*è®¾ç½®P0.0ä¸ºå‡†åŒå‘å£*/
 306   2          //     GPIO_InitStruct.Mode = GPIO_PullUp;
 307   2          //     GPIO_InitStruct.Pin = GPIO_Pin_0;
 308   2          //     GPIO_Inilize(GPIO_P0, &GPIO_InitStruct);
 309   2      
 310   2          //     // GPIO_InitStruct.Mode = GPIO_OUT_OD;
 311   2          //     // GPIO_InitStruct.Pin = GPIO_Pin_0;
 312   2          //     // GPIO_Inilize(GPIO_P0, &GPIO_InitStruct);
 313   2      
 314   2          //     /*è®¾ç½®P0.1ä¸ºæ¨æŒ½è¾“å‡º*/
 315   2          //     GPIO_InitStruct.Mode = GPIO_OUT_PP;
 316   2          //     GPIO_InitStruct.Pin = GPIO_Pin_1;
 317   2          //     GPIO_Inilize(GPIO_P0, &GPIO_InitStruct);
 318   2          // }
 319   2          // break;
 320   2          // case UART4:
 321   2          // {
 322   2          //     S4CON = uart_baseHandle->Register_SCON;
 323   2          //     T4T3M |= uart_baseHandle->Uart_Mode; // æ­¤å¤„ä¸²å£3å’Œä¸²å£4å…±ç”¨
 324   2          //     T4L = uart_baseHandle->Uart_Count;
 325   2          //     T4H = uart_baseHandle->Uart_Count >> 8;
 326   2          //     IE2 |= (uart_baseHandle->Interrupt_Enable & 0x10); // ä¸²å£4ä¸­æ–­å…è®¸ä½
 327   2      
 328   2          //     /*è®¾ç½®P0.2ä¸ºå‡†åŒå‘å£*/
 329   2          //     GPIO_InitStruct.Mode = GPIO_PullUp;
 330   2          //     GPIO_InitStruct.Pin = GPIO_Pin_2;
 331   2          //     GPIO_Inilize(GPIO_P0, &GPIO_InitStruct);
 332   2      
 333   2          //     /*è®¾ç½®P0.3ä¸ºæ¨æŒ½è¾“å‡º*/
 334   2          //     GPIO_InitStruct.Mode = GPIO_OUT_PP;
 335   2          //     GPIO_InitStruct.Pin = GPIO_Pin_3;
 336   2          //     GPIO_Inilize(GPIO_P0, &GPIO_InitStruct);
 337   2          // }
 338   2          // break;
 339   2          default:
 340   2              break;
 341   2          }
 342   1      }
 343          
 344          #if (DWIN_USING_RB)
              /*********************************************************
               * å‡½æ•°åï¼šstatic void Busy_Await(Uart_HandleTypeDef * const Uart, uint16_t overtime)
               * åŠŸèƒ½ï¼š  å­—èŠ‚å‘é€è¶…æ—¶ç­‰å¾…æœºåˆ¶
               * å‚æ•°ï¼š  Uart_HandleTypeDef * const Uart;uint16_t overtime
               * ä½œè€…ï¼š  LHC
               * noteï¼š
               *
               **********************************************************/
              void Busy_Await(Uart_HandleTypeDef *const Uart, uint16_t overtime)
              {
              
                  while (Uart->Uartx_busy) // ç­‰å¾…å‘é€å®Œæˆï¼šUart->Uartx_busyæ¸…é›¶
                  {
                      if (!(overtime--))
                          break;
                  }
              
                  Uart->Uartx_busy = true; // å‘é€æ•°æ®ï¼ŒæŠŠç›¸åº”ä¸²å£ç½®å¿™
C51 COMPILER V9.60.0.0   USART                                                             01/14/2023 22:17:10 PAGE 7   

              }
              #endif
 365          
 366          /*********************************************************
 367           * å‡½æ•°åï¼šUartx_SendStr(Uart_HandleTypeDef *const Uart,uint8_t *p,uint8_t length)
 368           * åŠŸèƒ½ï¼š  æ‰€æœ‰ä¸²å£å­—ç¬¦ä¸²å‘é€å‡½æ•°
 369           * å‚æ•°ï¼š  Uart_HandleTypeDef *const Uart,uint8_t *p;uint8_t length
 370           * ä½œè€…ï¼š  LHC
 371           * noteï¼š
 372           *
 373           **********************************************************/
 374          void Uartx_SendStr(Uart_HandleTypeDef *const Uart,
 375                             uint8_t *p,
 376                             uint8_t length,
 377                             uint16_t time_out)
 378          {
 379   1          if (NULL == Uart || !length)
 380   1              return;
 381   1      
 382   1          while (length--)
 383   1          {
 384   2      #if (DWIN_USING_RB)
                      Busy_Await(&(*Uart), time_out); // ç­‰å¾…å½“å‰å­—èŠ‚å‘é€å®Œæˆ
                      switch (Uart->Instance)
                      {
                      case UART1:
                          SBUF = *p++;
                          break;
                      case UART2:
                          S2BUF = *p++;
                          break;
                      case UART3:
                          S3BUF = *p++;
                          break;
                      case UART4:
                          S4BUF = *p++;
                          break;
                      default:
                          break;
                      }
              #else
 404   2      #define S1BUF SBUF
 405   2      #define S1CON TI
 406   2      #define S1TI 1
 407   2      #define UARTX_TX(_id)                                       \
 408   2          do                                                      \
 409   2          {                                                       \
 410   2              S##_id##BUF = *p++;                                 \
 411   2              while (!(S##_id##CON & S##_id##TI) && (--time_out)) \
 412   2                  ;                                               \
 413   2              S##_id##CON = (S##_id##CON & ~S##_id##TI);          \
 414   2          } while (0)
 415   2      
 416   2              switch (Uart->Instance)
 417   2              {
 418   3              case UART1:
 419   3                  // TI = 0;
 420   3                  UARTX_TX(1);
 421   3                  break;
 422   3              case UART2:
 423   3                  UARTX_TX(2);
 424   3                  break;
C51 COMPILER V9.60.0.0   USART                                                             01/14/2023 22:17:10 PAGE 8   

 425   3              case UART3:
 426   3                  UARTX_TX(3);
 427   3                  break;
 428   3              case UART4:
 429   3                  UARTX_TX(4);
 430   3                  break;
 431   3              default:
 432   3                  break;
 433   3              }
 434   2      #undef S1CON
 435   2      #undef S1TI
 436   2      #undef S1BUF
 437   2      #endif
 438   2          }
 439   1      }
 440          
 441          // #if !defined USING_SIMULATE
 442          /*********************************************************
 443           * å‡½æ•°åï¼šchar putchar(char str)
 444           * åŠŸèƒ½ï¼š  putcharé‡å®šå‘,è¢«printfè°ƒç”¨
 445           * å‚æ•°ï¼š  char strï¼Œå‘é€çš„å­—ç¬¦ä¸²
 446           * ä½œè€…ï¼š  LHC
 447           * noteï¼š
 448           *                ä½¿ç”¨printfå‡½æ•°å°†ä¼šå ç”¨1K å·¦å³FLASH
 449           **********************************************************/
 450          // static char idata buf[128] = {0};
 451          void Uartx_Printf(Uart_HandleTypeDef *const uart, const char *format, ...)
 452          {
 453   1          uint16_t length = 0;
 454   1          va_list ap;
 455   1      
 456   1          char idata buf[128] = {0};
 457   1          // memset(buf, 0x00, sizeof(buf));
 458   1          va_start(ap, format);
 459   1          /*ä½¿ç”¨å¯å˜å‚æ•°çš„å­—ç¬¦ä¸²æ‰“å°,ç±»ä¼¼sprintf*/
 460   1          length = vsprintf(buf, format, ap);
 461   1          va_end(ap);
 462   1          if (uart)
 463   1              Uartx_SendStr(uart, (uint8_t *)buf, length, UART_BYTE_SENDOVERTIME);
 464   1      }
 465          // #endif
 466          /**********************************å…¬ç”¨å‡½æ•°************************/


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    614    ----
   CONSTANT SIZE    =    130    ----
   XDATA SIZE       =     22      63
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----     128
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
