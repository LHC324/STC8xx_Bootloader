C51 COMPILER V9.60.0.0   USART                                                             01/03/2023 21:14:42 PAGE 1   


C51 COMPILER V9.60.0.0, COMPILATION OF MODULE USART
OBJECT MODULE PLACED IN .\Objects\usart.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE Src\usart.c LARGE OPTIMIZE(9,SPEED) BROWSE FLOATFUZZY(4) INCDIR(.\Inc) D
                    -EBUG OBJECTEXTEND PRINT(.\Listings\usart.lst) OBJECT(.\Objects\usart.obj)

line level    source

   1          #include "usart.h"
   2          
   3          /*********************************************************
   4          * å‡½æ•°åï¼š
   5          * åŠŸèƒ½ï¼š
   6          * å‚æ•°ï¼š
   7          * ä½œè€…ï¼š
   8          * noteï¼š
   9                  åŒæ—¶ä½¿ç”¨å¤šä¸ªä¸²å£çš„æ—¶å€™ä¼šå‡ºçŽ°æ•°æ®ä¼ è¾“é”™è¯¯çš„æƒ…å†µ å»ºè®®åœ¨ä½¿ç”¨è¯¥æ¿å­ä¸Žå
             -…¶ä»–
  10                  é€šè®¯æ¨¡å—å»ºç«‹é€šè®¯çš„æ—¶å€™ä½¿ç”¨1å¯¹1çš„å»ºç«‹è¿žæŽ¥çš„æ¨¡å¼
  11          
  12                  è§£å†³äº†å¤šä¸²å£åŒæ—¶æ•°æ®ä¼ è¾“é”™è¯¯é—®é¢˜ //2021/5/31
  13          
  14                  åœ¨åˆ‡æ¢ä¸²å£çš„å¼•è„šè¾“å…¥æ—¶ï¼Œå»ºè®®å°†RXç«¯åˆå§‹åŒ–çš„æ—¶å€™ç»™ä¸ª0å€¼ TXå¼•è„šæ‰‹åŠ¨ç»™ä¸
             -ª1å€¼
  15                  ï¼ˆåŸºäºŽSTCå•ç‰‡æœºçš„ç‰¹æ€§ï¼‰
  16          
  17          **********************************************************/
  18          
  19          #if (OTA_UART != 5U)
              void (*IspProgram)(void) = ISP_PROGRAM_ADDR;
              char cnt7f = 0;
              #else
  23          Uartx_HandleTypeDef xdata Boot_Rx = {0};
  24          #endif
  25          
  26          Uart_HandleTypeDef Uart1; // ä¸²å£1å¥æŸ„
  27          Uart_HandleTypeDef Uart2; // ä¸²å£2å¥æŸ„
  28          Uart_HandleTypeDef Uart3; // ä¸²å£3å¥æŸ„
  29          Uart_HandleTypeDef Uart4; // ä¸²å£4å¥æŸ„
  30          
  31          /*********************************************************
  32           * å‡½æ•°åï¼švoid Uart_1Init(void)
  33           * åŠŸèƒ½ï¼š  ä¸²å£1çš„åˆå§‹åŒ–
  34           * å‚æ•°ï¼š
  35           * ä½œè€…ï¼š  LHC
  36           * noteï¼š
  37           *              ä½¿ç”¨çš„æ˜¯å®šæ—¶å™¨1ä½œä¸ºæ³¢ç‰¹çŽ‡å‘ç”Ÿå™¨,LANå£ç”¨
  38           **********************************************************/
  39          void Uart1_Init(void) // ä¸²å£1é€‰æ‹©å®šæ—¶å™¨1ä½œä¸ºæ³¢ç‰¹çŽ‡å‘ç”Ÿå™¨
  40          {
  41   1          Uart1.Instance = UART1;
  42   1          Uart1.Register_SCON = 0x50; // æ¨¡å¼1ï¼Œ8ä½æ•°æ®ï¼Œå¯å˜æ³¢ç‰¹çŽ‡
  43   1          Uart1.Uart_Mode = 0x00;     // å®šæ—¶å™¨æ¨¡å¼0ï¼Œ16bitè‡ªåŠ¨é‡è½½
  44   1          Uart1.Uart_Count = BRT_1T(BAUD_115200);
  45   1          Uart1.RunUart_Enable = true;
  46   1          Uart1.Interrupt_Enable = true;
  47   1          Uart1.Register_AUXR = 0x40;  // å®šæ—¶å™¨1ï¼Œ1Tæ¨¡å¼
  48   1          Uart1.Register_AUXR &= 0xFE; // æ³¢ç‰¹çŽ‡å‘ç”Ÿå™¨é€‰ç”¨å®šæ—¶å™¨1ï¼Œæœ€å¥½æŒ‰ç…§è¦æ±‚æ¥
  49   1      
  50   1          Uart1.Uart_NVIC.Register_IP = 0xEF; // PS=0,PSH=0,ä¸²å£1ä¸­æ–­ä¼˜å…ˆçº§ä¸ºç¬¬0çº§ï¼Œæœ€ä½Žçº§
  51   1          Uart1.Uart_NVIC.Register_IPH = 0xEF;
  52   1      
C51 COMPILER V9.60.0.0   USART                                                             01/03/2023 21:14:42 PAGE 2   

  53   1          Uart_Base_MspInit(&Uart1);
  54   1      }
  55          
  56          // #if (OTA_UART != 5U)
  57          /*********************************************************
  58           * å‡½æ•°åï¼švoid Uart1_ISR() interrupt 4 using 2
  59           * åŠŸèƒ½ï¼š  ä¸²å£1çš„å®šæ—¶ä¸­æ–­æœåŠ¡å‡½æ•°
  60           * å‚æ•°ï¼š
  61           * ä½œè€…ï¼š  LHC
  62           * noteï¼š
  63           *              ä½¿ç”¨çš„æ˜¯å®šæ—¶å™¨2ä½œä¸ºæ³¢ç‰¹çŽ‡å‘ç”Ÿå™¨,485å£ç”¨
  64           **********************************************************/
  65          void Uart1_ISR() interrupt 4 using 2 // ä¸²å£1çš„å®šæ—¶ä¸­æ–­æœåŠ¡å‡½æ•°
  66          {
  67   1          if (TI) // å‘é€ä¸­æ–­æ ‡å¿—
  68   1          {
  69   2              TI = 0;
  70   2              Uart1.Uartx_busy = false; // å‘é€å®Œæˆï¼Œæ¸…é™¤å ç”¨
  71   2          }
  72   1      
  73   1          if (RI) // æŽ¥æ”¶ä¸­æ–­æ ‡å¿—
  74   1          {
  75   2      #if (OTA_UART == 1)
                      if (SBUF == 0x7F)
                      {
                          cnt7f++;
                          if (cnt7f >= 16)
                          {
                              IspProgram();
                          }
                      }
                      else
                      {
                          cnt7f = 0;
                      }
              #endif
  89   2      
  90   2              RI = 0;
  91   2          }
  92   1      }
  93          // #endif
  94          
  95          /*********************************************************
  96           * å‡½æ•°åï¼švoid Uart_2Init(void)
  97           * åŠŸèƒ½ï¼š  ä¸²å£2çš„åˆå§‹åŒ–
  98           * å‚æ•°ï¼š
  99           * ä½œè€…ï¼š  LHC
 100           * noteï¼š
 101           *              ä½¿ç”¨çš„æ˜¯å®šæ—¶å™¨2ä½œä¸ºæ³¢ç‰¹çŽ‡å‘ç”Ÿå™¨,485å£ç”¨
 102           **********************************************************/
 103          void Uart2_Init(void) // ä¸²å£2é€‰æ‹©å®šæ—¶å™¨2ä½œä¸ºæ³¢ç‰¹çŽ‡å‘ç”Ÿå™¨
 104          {
 105   1          Uart2.Instance = UART2;
 106   1          Uart2.Register_SCON = 0x10; // æ¨¡å¼1ï¼Œ8ä½æ•°æ®ï¼Œå¯å˜æ³¢ç‰¹çŽ‡ï¼Œå¼€å¯ä¸²å£2æŽ¥æ”¶
 107   1          Uart2.Uart_Mode = 0x00;     // å®šæ—¶å™¨æ¨¡å¼0ï¼Œ16bitè‡ªåŠ¨é‡è½½
 108   1          Uart2.Uart_Count = BRT_1T(BAUD_115200);
 109   1          Uart2.RunUart_Enable = true;
 110   1          Uart2.Interrupt_Enable = 0x01;
 111   1          Uart2.Register_AUXR = 0x14;         // å¼€å¯å®šæ—¶å™¨2ï¼Œ1Tæ¨¡å¼
 112   1          Uart2.Uart_NVIC.Register_IP = 0x01; // PS2=1,PS2H=0,ä¸²å£2ä¸­æ–­ä¼˜å…ˆçº§ä¸ºç¬¬1çº§
 113   1          Uart2.Uart_NVIC.Register_IPH = 0xFE;
 114   1      
C51 COMPILER V9.60.0.0   USART                                                             01/03/2023 21:14:42 PAGE 3   

 115   1          Uart_Base_MspInit(&Uart2);
 116   1      }
 117          
 118          // #if (OTA_UART != 5U)
 119          /*********************************************************
 120           * å‡½æ•°åï¼švoid Uart2_ISR() interrupt 8 using 2
 121           * åŠŸèƒ½ï¼š  ä¸²å£2ä¸­æ–­å‡½æ•°
 122           * å‚æ•°ï¼š
 123           * ä½œè€…ï¼š  LHC
 124           * noteï¼š
 125           *              ä½¿ç”¨çš„æ˜¯å®šæ—¶å™¨2ä½œä¸ºæ³¢ç‰¹çŽ‡å‘ç”Ÿå™¨,4Gå£ç”¨
 126           **********************************************************/
 127          void Uart2_ISR() interrupt 8 using 2
 128          {
 129   1          if (S2CON & S2TI) // å‘é€ä¸­æ–­
 130   1          {
 131   2              S2CON &= ~S2TI;
 132   2              Uart2.Uartx_busy = false; // å‘é€å®Œæˆï¼Œæ¸…é™¤å ç”¨
 133   2          }
 134   1      
 135   1          if (S2CON & S2RI) // æŽ¥æ”¶ä¸­æ–­
 136   1          {
 137   2              S2CON &= ~S2RI;
 138   2      
 139   2      #if (OTA_UART == 2)
                      if (S2BUF == 0x7F)
                      {
                          cnt7f++;
                          if (cnt7f >= 16)
                          {
                              IspProgram();
                          }
                      }
                      else
                      {
                          cnt7f = 0;
                      }
              #endif
 153   2          }
 154   1      }
 155          // #endif
 156          
 157          /**********************************å…¬ç”¨å‡½æ•°************************/
 158          
 159          /*********************************************************
 160           * å‡½æ•°åï¼šUart_Base_MspInit(Uart_HandleTypeDef *uart_baseHandle)
 161           * åŠŸèƒ½ï¼š  æ‰€æœ‰ä¸²å£åº•å±‚åˆå§‹åŒ–å‡½æ•°
 162           * å‚æ•°ï¼š  Uart_HandleTypeDef *uart_baseHandleä¸²å£å¥æŸ„
 163           * ä½œè€…ï¼š  LHC
 164           * noteï¼š
 165           *              æ³¨æ„æ­£ç¡®ç»™å‡ºä¸²å£å¥æŸ„
 166           **********************************************************/
 167          void Uart_Base_MspInit(Uart_HandleTypeDef *const uart_baseHandle)
 168          {
 169   1          if (uart_baseHandle->Instance == UART1)
 170   1          {
 171   2              SCON = uart_baseHandle->Register_SCON;
 172   2              TMOD |= uart_baseHandle->Uart_Mode;
 173   2              TL1 = uart_baseHandle->Uart_Count;
 174   2              TH1 = uart_baseHandle->Uart_Count >> 8;
 175   2              TR1 = uart_baseHandle->RunUart_Enable;
 176   2              AUXR |= uart_baseHandle->Register_AUXR;
C51 COMPILER V9.60.0.0   USART                                                             01/03/2023 21:14:42 PAGE 4   

 177   2              IP &= uart_baseHandle->Uart_NVIC.Register_IP;
 178   2              IPH &= uart_baseHandle->Uart_NVIC.Register_IPH;
 179   2      #if USEING_PRINTF // å¦‚æžœä½¿ç”¨printf
                      TI = 1;   // æ”¾åˆ°printfé‡å®šå‘
              #else
 182   2              ES = uart_baseHandle->Interrupt_Enable; // ä¸²å£1ä¸­æ–­å…è®¸ä½
 183   2      #endif
 184   2          }
 185   1          else if (uart_baseHandle->Instance == UART2)
 186   1          {
 187   2              S2CON = uart_baseHandle->Register_SCON;
 188   2              TL2 = uart_baseHandle->Uart_Count;
 189   2              TH2 = uart_baseHandle->Uart_Count >> 8;
 190   2              AUXR |= uart_baseHandle->Register_AUXR;
 191   2              IE2 |= uart_baseHandle->Interrupt_Enable; // ä¸²å£2ä¸­æ–­å…è®¸ä½
 192   2              IP2 &= uart_baseHandle->Uart_NVIC.Register_IP;
 193   2              IP2H &= uart_baseHandle->Uart_NVIC.Register_IPH;
 194   2          }
 195   1          else if (uart_baseHandle->Instance == UART3)
 196   1          {
 197   2              S3CON = uart_baseHandle->Register_SCON;
 198   2              T4T3M = uart_baseHandle->Uart_Mode;
 199   2              T3L = uart_baseHandle->Uart_Count;
 200   2              T3H = uart_baseHandle->Uart_Count >> 8;
 201   2              IE2 |= uart_baseHandle->Interrupt_Enable; // ä¸²å£3ä¸­æ–­å…è®¸ä½
 202   2          }
 203   1          else if (uart_baseHandle->Instance == UART4)
 204   1          {
 205   2              S4CON = uart_baseHandle->Register_SCON;
 206   2              T4T3M |= uart_baseHandle->Uart_Mode; // æ­¤å¤„ä¸²å£3å’Œä¸²å£4å…±ç”¨
 207   2              T4L = uart_baseHandle->Uart_Count;
 208   2              T4H = uart_baseHandle->Uart_Count >> 8;
 209   2              IE2 |= uart_baseHandle->Interrupt_Enable; // ä¸²å£4ä¸­æ–­å…è®¸ä½
 210   2          }
 211   1      }
 212          
 213          #if (!OTA_UART)
              /*********************************************************
               * å‡½æ•°åï¼šstatic void Busy_Await(Uart_HandleTypeDef * const Uart, uint16_t overtime)
               * åŠŸèƒ½ï¼š  å­—èŠ‚å‘é€è¶…æ—¶ç­‰å¾…æœºåˆ¶
               * å‚æ•°ï¼š  Uart_HandleTypeDef * const Uart;uint16_t overtime
               * ä½œè€…ï¼š  LHC
               * noteï¼š
               *
               **********************************************************/
              void Busy_Await(Uart_HandleTypeDef *const Uart, uint16_t overtime)
              {
              
                  while (Uart->Uartx_busy) // ç­‰å¾…å‘é€å®Œæˆï¼šUart->Uartx_busyæ¸…é›¶
                  {
                      if (!(overtime--))
                          break;
                  }
              
                  Uart->Uartx_busy = true; // å‘é€æ•°æ®ï¼ŒæŠŠç›¸åº”ä¸²å£ç½®å¿™
              }
              #endif
 234          
 235          /*********************************************************
 236           * å‡½æ•°åï¼šUartx_SendStr(Uart_HandleTypeDef *const Uart,uint8_t *p,uint8_t length)
 237           * åŠŸèƒ½ï¼š  æ‰€æœ‰ä¸²å£å­—ç¬¦ä¸²å‘é€å‡½æ•°
 238           * å‚æ•°ï¼š  Uart_HandleTypeDef *const Uart,uint8_t *p;uint8_t length
C51 COMPILER V9.60.0.0   USART                                                             01/03/2023 21:14:42 PAGE 5   

 239           * ä½œè€…ï¼š  LHC
 240           * noteï¼š
 241           *
 242           **********************************************************/
 243          void Uartx_SendStr(Uart_HandleTypeDef *const Uart,
 244                             uint8_t *p,
 245                             uint8_t length,
 246                             uint16_t time_out)
 247          {
 248   1          if (NULL == Uart || !length)
 249   1              return;
 250   1      
 251   1          while (length--)
 252   1          {
 253   2      #if (!OTA_UART)
                      Busy_Await(&(*Uart), time_out); // ç­‰å¾…å½“å‰å­—èŠ‚å‘é€å®Œæˆ
                      switch (Uart->Instance)
                      {
                      case UART1:
                          SBUF = *p++;
                          break;
                      case UART2:
                          S2BUF = *p++;
                          break;
                      case UART3:
                          S3BUF = *p++;
                          break;
                      case UART4:
                          S4BUF = *p++;
                          break;
                      default:
                          break;
                      }
              #else
 273   2      #define S1BUF SBUF
 274   2      #define S1CON TI
 275   2      #define S1TI 1
 276   2      #define UARTX_TX(_id)                                       \
 277   2          do                                                      \
 278   2          {                                                       \
 279   2              S##_id##BUF = *p++;                                 \
 280   2              while (!(S##_id##CON & S##_id##TI) && (--time_out)) \
 281   2                  ;                                               \
 282   2              S##_id##CON = (S##_id##CON & ~S##_id##TI);          \
 283   2          } while (0)
 284   2      
 285   2              switch (Uart->Instance)
 286   2              {
 287   3              case UART1:
 288   3                  // TI = 0;
 289   3                  UARTX_TX(1);
 290   3                  break;
 291   3              case UART2:
 292   3                  UARTX_TX(2);
 293   3                  break;
 294   3              case UART3:
 295   3                  UARTX_TX(3);
 296   3                  break;
 297   3              case UART4:
 298   3                  UARTX_TX(4);
 299   3                  break;
 300   3              default:
C51 COMPILER V9.60.0.0   USART                                                             01/03/2023 21:14:42 PAGE 6   

 301   3                  break;
 302   3              }
 303   2      #undef S1CON
 304   2      #undef S1TI
 305   2      #undef S1BUF
 306   2              // switch (Uart->Instance)
 307   2              // {
 308   2              // case UART1:
 309   2              //     TI = 0;
 310   2              //     SBUF = *p++;
 311   2              //     while (!TI && (--time_out))
 312   2              //         ;
 313   2              //     break;
 314   2              // case UART2:
 315   2              // S2CON &= ~S2TI;
 316   2              //     S2BUF = *p++;
 317   2              //     while (!(S2CON & S2TI) && (--time_out))
 318   2              //         ;
 319   2              //     break;
 320   2              // case UART3:
 321   2              //     S3CON &= ~S3TI;
 322   2              //     S3BUF = *p++;
 323   2              //     while (!(S3CON & S3TI) && (--time_out))
 324   2              //         ;
 325   2              //     break;
 326   2              // case UART4:
 327   2              //     S4CON &= ~S4TI;
 328   2              //     S4BUF = *p++;
 329   2              //     while (!(S4CON & S4TI) && (--time_out))
 330   2              //         ;
 331   2              //     break;
 332   2              // default:
 333   2              //     break;
 334   2              // }
 335   2      #endif
 336   2          }
 337   1      }
 338          
 339          #if (USE_PRINTF_DEBUG == 1)
 340          /*********************************************************
 341           * å‡½æ•°åï¼šchar putchar(char str)
 342           * åŠŸèƒ½ï¼š  putcharé‡å®šå‘,è¢«printfè°ƒç”¨
 343           * å‚æ•°ï¼š  char strï¼Œå‘é€çš„å­—ç¬¦ä¸²
 344           * ä½œè€…ï¼š  LHC
 345           * noteï¼š
 346           *                ä½¿ç”¨printfå‡½æ•°å°†ä¼šå ç”¨1K å·¦å³FLASH
 347           **********************************************************/
 348          // static char idata buf[128] = {0};
 349          void Uartx_Printf(Uart_HandleTypeDef *const uart, const char *format, ...)
 350          {
 351   1          uint16_t length = 0;
 352   1          va_list ap;
 353   1      
 354   1          char idata buf[128] = {0};
 355   1          // memset(buf, 0x00, sizeof(buf));
 356   1          va_start(ap, format);
 357   1          /*ä½¿ç”¨å¯å˜å‚æ•°çš„å­—ç¬¦ä¸²æ‰“å°,ç±»ä¼¼sprintf*/
 358   1          length = vsprintf(buf, format, ap);
 359   1          va_end(ap);
 360   1          if (uart)
 361   1              Uartx_SendStr(uart, (uint8_t *)buf, length, UART_BYTE_SENDOVERTIME);
 362   1      }
C51 COMPILER V9.60.0.0   USART                                                             01/03/2023 21:14:42 PAGE 7   

 363          #endif
 364          
 365          #if (OTA_UART == 5U)
 366          // /**
 367          //  * @brief    ä¸²å£å‘é€ä¸€ä¸ªå­—èŠ‚.
 368          //  * @version V1.0.0,2022/01/18
 369          //  * @details
 370          //  * @param    None
 371          //  * @retval   None
 372          //  */
 373          // void Uart_PutByte(uint8_t str)
 374          // {
 375          //     RESET_OTA_TI();
 376          //     OTA_UART_SBUF = str;
 377          //     while (!OTA_UART_TI)
 378          //     {
 379          //         _nop_();
 380          //     };
 381          // }
 382          
 383          // /**
 384          //  * @brief    ä¸²å£å‘é€å­—ç¬¦ä¸².
 385          //  * @version V1.0.0,2022/01/18
 386          //  * @details
 387          //  * @param    None
 388          //  * @retval   None
 389          //  */
 390          // void Uart_PutString(uint8_t *pstr)
 391          // {
 392          //     for (; *pstr > 0; pstr++)
 393          //     {
 394          //         Uart_PutByte(*pstr);
 395          //     }
 396          // }
 397          #endif
 398          /**********************************å…¬ç”¨å‡½æ•°************************/


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    682    ----
   CONSTANT SIZE    =    128    ----
   XDATA SIZE       =   1078      58
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----     128
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
